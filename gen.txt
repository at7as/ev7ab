nextProject(project) {
  project more complex
  create project with levels = 0
}

gen() {
  // if top == nil
  // gen POP_SIZE with min_level
  // when set top, then set min_level with current level
  nextProject(project or nil)


}

mut() {

}

main() {

  gen()
  mut()

}




2 diff pops: GEN and EVO

config:

POP_SIZE

main() { 0: }

0:
create project (prod) with levels = 0
then 1:

1:
gen()
mut()

produce and sort result
check result for goal
if goal and result better then s.goal = e, if cfg.goal then end
if not goal
if result better then top = e and 1:
if result not better then 2: 

2:
repop
if pop ??? then pop ??? then 1:
if pop ??? then 3:

4:
create next project (evo), init pop, init level

when EVO than PROD, then PROD = EVO, EVO = nil

* gen(random, mutate, recomb)
??? * count -- init when new
??? * attempts w\o rise
9 level -- 0 when new

new (
4 aggr
12 proc
* size
)

level -- it`s for fine tuning
min_level -- in stage, setted when first entity has result